# 相机视角不匹配问题 - 调试上下文

## 当前问题

渲染输出图片中，**View 4（第5个视图）始终与GT不匹配**，其他9个view都正确。
- View 4的渲染结果中物体是"躺着的"（旋转了约90度），GT中物体是正常站立的
- 这个问题在**所有样本**中都出现，不是个别样本的问题

## 索引映射关系

```
input_indices = [1, 2, 3, 4]          # 4个输入视图
supervision_indices = [0, 11, 18, 26, 33, 40]  # 6个监督视图
all_indices = [1, 2, 3, 4, 0, 11, 18, 26, 33, 40]
```

run_pipeline.py 中合并：
```python
all_transforms = cat([input_transforms, supervision_transforms], dim=1)  # [B, 10, 4, 4]
all_gt_images = cat([input_rgb, supervision_images], dim=1)              # [B, 10, 3, H, W]
```

所以：
- View 0-3 = input views（原始视图1,2,3,4）
- **View 4 = supervision_transforms[0] = cam_poses[4] = 原始视图0**
- View 5-9 = supervision views（原始视图11,18,26,33,40）

## 根因分析（已确认）

### Objaverse 数据集的原始视图0是特殊的

**所有样本的原始视图0都有单位旋转矩阵**（缩放的I矩阵），例如：
```
transform_matrix:
[0.115, 0, 0, 0]
[0, 0.115, 0, 0]
[0, 0, 0.115, -0.057]
[0, 0, 0, 1]
```
- 旋转部分 = 0.115 * I（SVD正交化后变为I）
- 位置 = [0, 0, -0.057]（radius极小，约0.057，其他视图radius=2.0）

### Y+Z翻转对原始视图0的影响（数值验证）

完整变换追踪（原始视图0）：

1. **原始**: R=I, pos=[0, 0, -0.057]
2. **缩放到1.5**: pos=[0, 0, -1.5]
3. **Blender→OpenGL**:
   - `c2w[1] *= -1` → pos=[0, 0, -1.5]
   - `c2w[[1,2]] = c2w[[2,1]]` → pos=[0, -1.5, 0]
   - `c2w[:3, 1:3] *= -1` → pos不变
   - R变为 `[[1,0,0],[0,0,-1],[0,1,0]]`
   - **forward(-Z) = [0, 1, 0]（朝向原点）✓**
   - **up(Y) = [0, 0, -1]**

4. **Y+Z翻转**（`cam_poses[:, :3, 1] *= -1; cam_poses[:, :3, 2] *= -1`）:
   - R变为 `[[1,0,0],[0,0,1],[0,-1,0]]`
   - **forward(-Z) = [0, -1, 0]（背对原点）✗**
   - **up(Y) = [0, 0, -1]**

**关键发现**：
- Camera 0（原始视图1）：翻转前 dot=-1（背对），翻转后 dot=+1（朝向）✓
- Camera 4（原始视图0）：翻转前 dot=+1（朝向），翻转后 dot=-1（背对）✗
- **Y+Z翻转对大多数相机有效，但对原始视图0（单位旋转矩阵）无效，反而把朝向翻反了**

### 已尝试的修复方案

1. **世界up [0,1,0] 重建旋转矩阵**（在R_align之后的重建步骤中）
   - 结果：View 4"还是偏"，角度有偏差但不是完全错误

2. **使用原始相机的up方向 R[:,1]**
   - 结果：View 4"换了一个方向歪"

3. **Gram-Schmidt正交化保持原始up**
   - 结果：与方案2"没区别"

4. **在Y+Z翻转前保存up方向，变换后使用**
   - 结果："没有任何区别"

5. **翻转后检测dot<0，翻转Y和Z回来**
   - 结果：朝向正确了，但up方向是[0,0,-1]而不是[0,1,0]，物体横躺

6. **翻转后检测dot<0，用look-at+世界up重建**（当前代码状态）
   - 结果：**还是躺着的**

## 当前代码状态

文件：`/mnt/huangjiaxin/3d-defense/data/dataset.py`

两个数据集类都有相同的处理流程：
- `OmniObject3DDataset`（约第487行起）
- `ObjaverseRenderedDataset`（约第881行起）

### 相机处理流程（当前代码）

```python
# 1. 加载原始c2w，除以scale
c2w[:3, :] /= scale

# 2. Blender → OpenGL
c2w[1] *= -1
c2w[[1, 2]] = c2w[[2, 1]]
c2w[:3, 1:3] *= -1

# 3. SVD正交化
U, _, Vt = torch.linalg.svd(R)
cam_poses[i, :3, :3] = U @ Vt

# 4. 缩放到radius=1.5
cam_poses[i, :3, 3] *= (target_radius / dist)

# 5. Y+Z翻转
cam_poses[:, :3, 1] *= -1
cam_poses[:, :3, 2] *= -1

# 6. 翻转后检测背对原点的相机，用look-at重建（当前修复）
for i in range(cam_poses.shape[0]):
    if dot_i < 0:
        # 用 look-at + 世界up [0,1,0] 重建旋转矩阵
        ...

# 7. R_align旋转对齐（使camera 0的旋转矩阵变为单位矩阵）
R_align = torch.inverse(cam_poses[0, :3, :3])
for i in range(cam_poses.shape[0]):
    cam_poses[i, :3, 3] = R_align @ cam_poses[i, :3, 3]
    cam_poses[i, :3, :3] = R_align @ cam_poses[i, :3, :3]

# 8. 重建旋转矩阵（dot<0.99的相机）
# 使用 Gram-Schmidt + 当前Y轴
```

### evaluator.py 渲染流程

```python
# 直接使用 transforms（OpenGL c2w）
cam_pose_colmap = cam_pose.clone()
cam_pose_colmap[:, :3, 1:3] *= -1  # OpenGL → COLMAP
cam_view = torch.inverse(cam_pose_colmap).transpose(1, 2)
cam_view_proj = cam_view @ proj_matrix
cam_pos = cam_pose_colmap[:, :3, 3]  # 不需要负号
```

### finetuner.py 训练流程

```python
# 也使用 transforms（OpenGL c2w）
cam_pose_colmap = cam_pose.clone()
cam_pose_colmap[:3, 1:3] *= -1
cam_view = torch.inverse(cam_pose_colmap).T
cam_view_proj = cam_view @ proj_matrix
cam_pos = -cam_pose_colmap[:3, 3]  # 注意：这里有负号！与evaluator不同！
```

**注意**：finetuner.py中`cam_pos = -cam_pose_colmap[:3, 3]`有负号，而evaluator.py中没有。这可能是另一个bug。

## 未解决的核心问题

Y+Z翻转对原始视图0（单位旋转矩阵）无效。需要找到一种变换方式，能同时正确处理：
- 普通相机（非单位旋转矩阵）→ Y+Z翻转有效
- 特殊相机（单位旋转矩阵，如原始视图0）→ Y+Z翻转无效

可能的方向：
1. 不用Y+Z翻转，找另一种统一的变换方式
2. 参考LGM原始代码 `LGM/core/provider_objaverse.py` 的处理方式，看它如何处理这种情况
3. 直接跳过原始视图0（从supervision_indices中排除）
4. 对原始视图0单独处理：不做Y+Z翻转，只做R_align

## 相关文件

- `data/dataset.py` - 数据集，相机处理逻辑
- `evaluation/evaluator.py` - 渲染评估
- `training/finetuner.py` - 训练时的数据准备
- `script/run_pipeline.py` - 端到端pipeline
- `LGM/core/provider_objaverse.py` - LGM原始数据加载器（参考）
- `test_camera_transform.py` - 相机变换测试脚本
- `test_actual_camera.py` - 实际数据相机变换测试

## Debug信息位置

dataset.py中有大量debug打印，包括：
- `[Dataset Debug]` / `[ObjaverseDataset Debug]` 前缀
- 打印 input_indices, supervision_indices, all_indices
- 打印每个相机的位置、旋转矩阵、前向方向
- 打印 supervision_transforms[0] 和 [4] 的位置
