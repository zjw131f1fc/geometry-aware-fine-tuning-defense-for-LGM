# 相机视角不匹配问题 - 调试上下文 v2

## 当前状态

代码已回滚到修复前状态。`data/dataset.py` 中两处 orbit_camera 修复已移除，替换为 TODO 注释。

## 问题描述

渲染输出图片中，**View 4（第5个视图，0-indexed）的预测结果与 GT 不匹配**：
- 当前状态（未修复）：View 4 的渲染结果中物体是"躺着的"（up 方向错误）
- 这个问题在**所有 Objaverse source 样本**中都出现
- 其他 9 个 view 都正确

## 索引映射关系（已确认）

所有 Objaverse 样本的视图选择结果一致：
```
input_indices = [1, 2, 3, 4]          # 4个输入视图
supervision_indices = [0, 11, 18, 26, 33, 40]  # 6个监督视图
all_indices = [1, 2, 3, 4, 0, 11, 18, 26, 33, 40]
```

run_pipeline.py 中合并：
```python
all_transforms = cat([input_transforms, supervision_transforms], dim=1)  # [B, 10, 4, 4]
all_gt_images = cat([input_rgb, supervision_images], dim=1)              # [B, 10, 3, H, W]
```

渲染图中列对应关系：
- 列 0-3 = input views（原始视图 1, 2, 3, 4）
- **列 4 = supervision_transforms[0] = cam_poses[4] = 原始视图 0** ← 有问题
- 列 5-9 = supervision views（原始视图 11, 18, 26, 33, 40）

## 根因分析（已确认）

### 原始视图 0 的特殊性

所有 Objaverse 样本的原始视图 0 都有**缩放的单位旋转矩阵**：
```
transform_matrix (样本 00d19183):
R = 0.0169 * I（SVD 正交化后变为 I）
pos/scale = [-6.89, -0.86, -90.84]（radius=91.1，其他视图 radius=118.2）
```

### 逐步变换追踪（样本 00d1918300634af48489467002fcb308）

**正常视图 1（cam[0]，对照组）：**

| 步骤 | pos | forward(-Z) | up(Y) | dot |
|------|-----|-------------|-------|-----|
| Step 1 除以scale | [111, 0, -40] | [-0.94, 0, 0.34] | [0.34, 0, 0.94] | +1.0 |
| Step 2 Blender→OpenGL | [111, -40, 0] | [0.94, -0.34, 0] | [-0.34, -0.94, 0] | **-1.0** |
| Step 4 缩放到1.5 | [1.41, -0.51, 0] | 同上 | 同上 | -1.0 |
| Step 5 Y+Z翻转 | 同上 | [-0.94, 0.34, 0] | [0.34, 0.94, 0] | **+1.0** ✓ |
| Step 6 不触发 | - | - | - | - |

**原始视图 0（cam[4]，有问题）：**

| 步骤 | pos | forward(-Z) | up(Y) | dot |
|------|-----|-------------|-------|-----|
| Step 1 除以scale | [-6.9, -0.9, -90.8] | [0, 0, -1] | [0, 1, 0] | -0.997 |
| Step 2 Blender→OpenGL | [-6.9, -90.8, 0.9] | **[0, 1, 0]** | **[0, 0, 1]** | **+0.997** |
| Step 4 缩放到1.5 | [-0.11, -1.50, 0.01] | 同上 | 同上 | +0.997 |
| Step 5 Y+Z翻转 | 同上 | **[0, -1, 0]** | **[0, 0, -1]** | **-0.997** ← 翻反了！ |
| Step 6 look-at重建 | 同上 | [0.08, 1.0, -0.01] | **[-0.99, 0.08, 0.12]** | +1.0 |

**关键发现：**
1. Blender→OpenGL 后，视图 0 的 up=[0,0,1]（Z方向），而正常视图的 up 在 XY 平面
2. Y+Z 翻转对 XY 平面的 up 有效，但对 Z 方向的 up 会翻反 forward
3. look-at 重建时，相机位置 ≈ [0, -1.5, 0] 接近 Y 轴
4. `cross(world_up=[0,1,0], z_axis≈[0,-1,0])` 的 norm=0.076，几乎退化
5. 重建出来的 up ≈ [-1, 0, 0]，完全错误

### R_align 后的最终结果

```
方案A（当前代码）所有相机的 pos 和 up：
cam[0](视图1): pos=[+0.000,+0.000,+1.500] up=[+0.000,+1.000,+0.000]  ✓
cam[1](视图2): pos=[+1.410,-0.482,+0.175] up=[+0.342,+0.883,-0.321]  ✓
cam[2](视图3): pos=[+0.000,-0.964,-1.149] up=[+0.000,+0.766,-0.643]  ✓
cam[3](视图4): pos=[-1.410,-0.482,+0.175] up=[-0.342,+0.883,-0.321]  ✓
cam[4](视图0): pos=[-0.014,-1.444,+0.405] up=[-0.124,-0.267,-0.956]  ✗ ← up 的 Y 分量为负！
cam[5](视图11):pos=[-0.997,-0.823,-0.761] up=[-0.242,+0.800,-0.549]  ✓
cam[6](视图18):pos=[+1.500,+0.000,-0.000] up=[-0.000,+0.940,-0.342]  ✓
cam[7](视图26):pos=[+1.061,-0.363,-0.997] up=[-0.000,+0.940,-0.342]  ✓
cam[8](视图33):pos=[-0.000,+0.964,+1.149] up=[-0.000,+0.766,-0.643]  ✓
cam[9](视图40):pos=[-1.302,+0.667,+0.331] up=[+0.316,+0.838,-0.444]  ✓
```

## 已尝试的修复方案

### 方案 1: orbit_camera 重建（失败 - 渲染全白）

在 R_align 后，对原始视图 0 用 orbit_camera 从位置反算 el/az 重建旋转矩阵。

```python
for i, orig_idx in enumerate(all_indices):
    if orig_idx == 0:
        pos = cam_poses[i, :3, 3]
        r = torch.norm(pos).item()
        el = float(np.degrees(np.arcsin(np.clip(pos[1].item() / r, -1, 1))))
        az = float(np.degrees(np.arctan2(pos[0].item(), pos[2].item())))
        c2w_orbit = orbit_camera(el, az, radius=r, opengl=True)
        cam_poses[i, :3, :3] = torch.from_numpy(c2w_orbit[:3, :3]).float()
```

结果：view 4 渲染完全空白（全白），Gaussian 从该角度不可见。
原因：orbit_camera 的旋转矩阵与当前坐标系不兼容。orbit_camera 假设标准 OpenGL 坐标系，
但当前坐标系经过 Y+Z 翻转 + R_align，与 orbit_camera 的约定不同。

验证数据：
- 修复前 up: [-0.124, -0.267, -0.956]（物体躺着但可见）
- 修复后 up: [+0.034, +0.270, -0.962]（物体不可见，全白）
- 其他 view 完全不变（pos差=0, up差=0）

### 方案 2: 按需翻转（未完整测试）

只对 dot<0 的相机做 Y+Z 翻转，已朝向原点的跳过。

结果：view 4 的 up 变成 [-1, 0, 0]，仍然不对（只是换了个方向歪）。
原因：原始视图 0 经过 Blender→OpenGL 后 up=[0,0,1]，不翻转的话 R_align 后 up 变成 [-1,0,0]。

### 方案 3: LGM 原始归一化（未测试）

用 LGM 的 `T_translate @ inv(cam_poses[0])` 替换整个 Y+Z翻转 + R_align 流程。

```python
T_translate = torch.tensor([[1,0,0,0],[0,1,0,0],[0,0,1,cam_radius],[0,0,0,1]])
transform = T_translate @ torch.inverse(cam_poses[0])
cam_poses = transform.unsqueeze(0) @ cam_poses
```

验证数据（方案B）：
- cam[0]: pos=[0,0,1.5], up=[0,1,0], dot=1.0 ✓
- cam[1-9]: dot 大多为负（背对原点），这在 LGM 中是正常的
- 但会改变所有 view 的旋转矩阵，不满足"其他 view 不变"的要求

### 方案 4: 排除原始视图 0（未测试）

从 supervision_indices 中排除原始视图 0，避免问题。
缺点：减少一个监督视图。

## 未解决的核心问题

需要找到一种方式，在不改变其他 view 的前提下，修复 view 4（原始视图 0）的旋转矩阵。

关键约束：
1. 其他 9 个 view 的 pos 和旋转矩阵必须完全不变
2. view 4 的 pos 不变（已正确）
3. view 4 的旋转矩阵需要修复，使渲染结果与 GT 匹配
4. orbit_camera 重建会导致渲染全白（坐标系不兼容）

可能的方向：
1. 搞清楚当前坐标系（Y+Z翻转 + R_align 后）与 orbit_camera 坐标系的关系，做正确的转换
2. 在 Y+Z 翻转之前保存视图 0 的旋转矩阵，翻转后用保存的版本（经过 R_align）替换
3. 修复 look-at 重建的退化问题（增大 cross product 退化检测阈值，用更好的 fallback up）
4. 直接排除原始视图 0

## 相关文件

| 文件 | 作用 |
|------|------|
| `data/dataset.py` | 数据集，相机处理逻辑（两个类：OmniObject3DDataset, ObjaverseRenderedDataset） |
| `evaluation/evaluator.py` | 渲染评估，`_render_from_transforms()` 和 `render_views()` |
| `training/finetuner.py` | 训练时的数据准备，`_prepare_data()` |
| `script/run_pipeline.py` | 端到端 pipeline，`render_samples()` 合并 transforms |
| `third_party/LGM/core/provider_objaverse.py` | LGM 原始数据加载器（参考） |
| `configs/config.yaml` | 配置文件 |
| `scripts/trace_view4.py` | 诊断脚本：追踪多个样本的 view 4 索引映射 |
| `scripts/trace_view4_detail.py` | 诊断脚本：逐步追踪视图 0 和视图 1 的变换 |
| `scripts/test_selective_flip.py` | 测试按需翻转方案 |
| `scripts/test_orbit_all.py` | 测试 orbit_camera 重建所有相机 |
| `scripts/test_fix_view0.py` | 测试只对视图 0 做 orbit_camera 重建 |

## 相机处理流程（当前代码，两个数据集类相同）

```python
# 1. 加载原始 c2w，除以 scale
c2w[:3, :] /= scale

# 2. Blender → OpenGL（与 LGM 第95-97行一致）
c2w[1] *= -1
c2w[[1, 2]] = c2w[[2, 1]]
c2w[:3, 1:3] *= -1

# 3. SVD 正交化
U, _, Vt = torch.linalg.svd(R)
cam_poses[i, :3, :3] = U @ Vt

# 4. 缩放到 radius=1.5
cam_poses[i, :3, 3] *= (target_radius / dist)

# 5. Y+Z 翻转
cam_poses[:, :3, 1] *= -1
cam_poses[:, :3, 2] *= -1

# 6. 翻转后检测背对原点的相机（dot<0），用 look-at + world_up=[0,1,0] 重建
#    ← 视图 0 在这里触发，但 cross product 退化导致 up 错误

# 7. R_align 旋转对齐（使 camera 0 的旋转矩阵变为单位矩阵）
R_align = torch.inverse(cam_poses[0, :3, :3])
for i: cam_poses[i] = R_align @ cam_poses[i]

# 8. 重建旋转矩阵（dot<0.99 的相机），用 Gram-Schmidt + 当前 Y 轴
#    ← 视图 0 的 dot=1.0，不触发此步骤

# TODO: 在这里修复视图 0 的旋转矩阵
```

## LGM 原始归一化方式（参考）

```python
# LGM/core/provider_objaverse.py 第127-128行
transform = torch.tensor([[1,0,0,0],[0,1,0,0],[0,0,1,cam_radius],[0,0,0,1]]) @ torch.inverse(cam_poses[0])
cam_poses = transform.unsqueeze(0) @ cam_poses  # [V, 4, 4]
```

这是一个统一的刚体变换，对所有相机（包括 R=I 的视图 0）都正确。
但会改变所有 view 的旋转矩阵，不满足"其他 view 不变"的约束。

## evaluator 和 finetuner 的 cam_pos 符号不一致

```python
# LGM 原始代码（provider_objaverse.py 第166行）
cam_pos = -cam_poses[:, :3, 3]  # 有负号

# evaluator._render_from_transforms（第275行）
cam_pos = cam_pose_colmap[:, :3, 3]  # 无负号 ← 与 LGM 不一致

# finetuner._prepare_data（第261行）
cam_pos = -cam_pose_colmap[:3, 3]  # 有负号 ← 与 LGM 一致
```

这是另一个潜在 bug，但可能不影响渲染结果（cam_pos 主要用于排序/culling）。

## 数据集路径

- Objaverse source 数据: `datas/objaverse_rendered/{uuid}/render/`
- OmniObject3D target 数据: `datas/omniobject3d___OmniObject3D-New/raw/blender_renders/{category}_{id}/render/`
- 测试用样本: `datas/objaverse_rendered/00d1918300634af48489467002fcb308/render/transforms.json`
- 最新渲染输出: `output/workspace/pipeline_sweep_ps_20260220_051231/`
